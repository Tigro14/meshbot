<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Carte R√©seau Meshtastic - Paris IDF vu par tigro G2 PV</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; overflow: hidden; }
        #map { width: 100%; height: 100vh; }
        
        .stats {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.85);
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            width: 280px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease-in-out;
        }
        
        .stats.collapsed {
            transform: translateX(calc(100% + 20px));
        }
        
        .stats-toggle {
            position: absolute;
            left: -40px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 8px 0 0 8px;
            padding: 12px 8px;
            cursor: pointer;
            box-shadow: -2px 0 10px rgba(0, 0, 0, 0.1);
            transition: all 0.2s;
            z-index: 1001;
        }
        
        .stats-toggle:hover {
            background: rgba(255, 255, 255, 1);
            box-shadow: -2px 0 15px rgba(0, 0, 0, 0.2);
        }
        
        .stats-toggle svg {
            display: block;
            width: 24px;
            height: 24px;
            transition: transform 0.3s;
        }
        
        .stats.collapsed .stats-toggle svg {
            transform: rotate(180deg);
        }
        
        .stats-header {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .stats-icon {
            width: 48px;
            height: 48px;
            margin-right: 12px;
        }
        
        .stats-title {
            font-size: 1.3rem;
            font-weight: 700;
            color: #1a73e8;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
        }
        
        .stat-label {
            font-weight: 500;
            color: #5f6368;
        }
        
        .stat-value {
            font-weight: 600;
            color: #1a73e8;
        }
        
        .view-buttons {
            display: flex;
            gap: 6px;
            margin-bottom: 12px;
        }
        
        .view-btn {
            flex: 1;
            padding: 8px 10px;
            border: 1px solid #dadce0;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            transition: all 0.2s;
            color: #5f6368;
        }
        
        .view-btn:hover {
            background: #f8f9fa;
            border-color: #1a73e8;
        }
        
        .view-btn.active {
            background: #1a73e8;
            color: white;
            border-color: #1a73e8;
        }
        
        .filter-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 12px;
        }
        
        .filter-btn {
            flex: 1;
            min-width: 60px;
            padding: 6px 10px;
            border: 1px solid #dadce0;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            transition: all 0.2s;
            color: #5f6368;
        }
        
        .filter-btn:hover {
            background: #f8f9fa;
            border-color: #1a73e8;
        }
        
        .filter-btn.active {
            background: #1a73e8;
            color: white;
            border-color: #1a73e8;
        }
        
        .search-container {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid rgba(0, 0, 0, 0.1);
        }
        
        .search-label {
            font-weight: 500;
            color: #5f6368;
            font-size: 0.85rem;
            margin-bottom: 6px;
        }
        
        .search-input-container {
            margin-bottom: 6px;
        }
        
        .search-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #dadce0;
            border-radius: 6px;
            font-size: 0.9rem;
            transition: all 0.2s;
        }
        
        .search-input:focus {
            outline: none;
            border-color: #1a73e8;
            box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.1);
        }
        
        .search-buttons {
            display: flex;
            gap: 6px;
            margin-bottom: 6px;
        }
        
        .search-btn {
            flex: 1;
            padding: 8px 16px;
            border: 1px solid #1a73e8;
            background: #1a73e8;
            color: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            transition: all 0.2s;
        }
        
        .search-btn:hover {
            background: #1557b0;
            border-color: #1557b0;
        }
        
        .clear-btn {
            flex: 1;
            padding: 8px 16px;
            border: 1px solid #dadce0;
            background: white;
            color: #5f6368;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            transition: all 0.2s;
        }
        
        .clear-btn:hover {
            background: #f8f9fa;
            border-color: #1a73e8;
        }
        
        .search-results-list {
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid #dadce0;
            border-radius: 6px;
            background: white;
            margin-bottom: 6px;
            display: none;
        }
        
        .search-results-list.visible {
            display: block;
        }
        
        .search-result-item {
            padding: 8px 12px;
            cursor: pointer;
            font-size: 0.85rem;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
            transition: background 0.2s;
        }
        
        .search-result-item:last-child {
            border-bottom: none;
        }
        
        .search-result-item:hover {
            background: #f8f9fa;
        }
        
        .search-result-item .node-name {
            font-weight: 600;
            color: #1a73e8;
        }
        
        .search-result-item .node-id {
            color: #5f6368;
            font-size: 0.8rem;
        }
        
        .filtered-tag {
            color: #d93025;
        }
        
        .search-result {
            font-size: 0.85rem;
            color: #5f6368;
            margin-top: 4px;
        }
        
        .search-result.success {
            color: #1e8e3e;
        }
        
        .search-result.error {
            color: #d93025;
        }
        
        .highlighted-marker {
            animation: pulse 1.5s ease-in-out 3;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.3); opacity: 1; }
        }
        
        .legend {
            background: rgba(255, 255, 255, 0.85);
            padding: 12px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.1);
        }
        
        .legend h4 {
            margin: 0 0 8px 0;
            color: #202124;
            font-size: 0.9rem;
            font-weight: 600;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 6px 0;
            font-size: 0.85rem;
        }
        
        .color-box {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 8px;
            border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }
        
        .legend-line {
            width: 30px;
            height: 3px;
            margin-right: 8px;
        }
        
        .owner-node {
            background-color: #e74c3c;
        }
        
        .leaflet-popup-content-wrapper {
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        }
        
        .leaflet-popup-content {
            margin: 12px;
            font-size: 0.9rem;
        }
        
        .popup-title {
            font-weight: 700;
            font-size: 1.1rem;
            color: #1a73e8;
            margin-bottom: 8px;
        }
        
        .popup-info {
            color: #5f6368;
            line-height: 1.6;
        }
        
        .popup-info strong {
            color: #202124;
        }
        
        .popup-info a {
            color: #1a73e8;
            text-decoration: none;
        }
        
        .popup-info a:hover {
            text-decoration: underline;
        }
        
        .node-label {
            font-size: 10px;
            font-weight: bold;
            color: #000;
            text-shadow: 0 0 3px #fff, 0 0 3px #fff, 0 0 3px #fff;
            white-space: nowrap;
            pointer-events: none;
            text-align: center;
            position: relative;
            top: -20px;
        }
        
        .node-emoji {
            font-size: 20px;
            pointer-events: none;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            line-height: 1;
            filter: drop-shadow(0 0 2px rgba(255, 255, 255, 0.8));
        }
        
        .node-emoji.emoji-only {
            font-size: 24px;
        }
        
        /* Legend collapsible styles */
        .legend-container {
            position: relative;
        }
        
        .legend.collapsed {
            transform: translateY(calc(100% + 10px));
        }
        
        .legend-toggle {
            position: absolute;
            top: -35px;
            right: 0;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 8px 8px 0 0;
            padding: 8px 12px;
            cursor: pointer;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
            transition: all 0.2s;
            font-size: 0.85rem;
            font-weight: 500;
            color: #5f6368;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .legend-toggle:hover {
            background: rgba(255, 255, 255, 1);
            box-shadow: 0 -2px 15px rgba(0, 0, 0, 0.2);
            color: #1a73e8;
        }
        
        .legend-toggle svg {
            width: 16px;
            height: 16px;
            transition: transform 0.3s;
        }
        
        .legend.collapsed + .legend-toggle svg {
            transform: rotate(180deg);
        }
        
        /* Mobile responsive styles */
        @media (max-width: 768px) {
            .stats {
                width: 250px;
                top: 10px;
                right: 10px;
                padding: 12px;
            }
            
            .stats-toggle {
                left: -35px;
                padding: 10px 6px;
            }
            
            .stats-toggle svg {
                width: 20px;
                height: 20px;
            }
            
            .legend {
                font-size: 0.8rem;
            }
            
            .legend-toggle {
                font-size: 0.75rem;
                padding: 6px 10px;
            }
        }
        
        @media (max-width: 480px) {
            .stats {
                width: calc(100vw - 60px);
                max-width: 250px;
            }
        }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <div class="stats">
        <button class="stats-toggle" onclick="toggleStats()" aria-label="Toggle menu">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M15 18l-6-6 6-6"/>
            </svg>
        </button>
        <div class="stats-header">
            <svg class="stats-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <circle cx="12" cy="12" r="10" stroke="#1a73e8" stroke-width="2"/>
                <path d="M12 6v6l4 2" stroke="#1a73e8" stroke-width="2" stroke-linecap="round"/>
            </svg>
            <div class="stats-title">R√©seau Mesh vu par tigro G2 PV</div>
        </div>
        
        <div class="view-buttons">
            <button class="view-btn" onclick="setView('nodes')">N≈ìuds</button>
            <button class="view-btn" onclick="setView('links')">Liens</button>
            <button class="view-btn active" onclick="setView('both')">Les deux</button>
        </div>
        
        <div class="stat-row">
            <span class="stat-label">N≈ìuds actifs</span>
            <span class="stat-value" id="visibleNodes">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Total n≈ìuds</span>
            <span class="stat-value" id="totalNodes">0</span>
        </div>
        <div class="stat-row" id="linksRow" style="display: flex;">
            <span class="stat-label">Liaisons</span>
            <span class="stat-value" id="totalLinks">0</span>
        </div>
        <div class="stat-row" style="border-bottom: none;">
            <span class="stat-label">Dernier entendu</span>
        </div>
        <div style="font-size: 0.85rem; color: #5f6368; margin-top: 4px;" id="lastHeard">
            Chargement...
        </div>
        
        <div class="filter-buttons">
            <button class="filter-btn" onclick="setTimeFilter('all')">Tout</button>
            <button class="filter-btn" onclick="setTimeFilter('2')">2h</button>
            <button class="filter-btn active" onclick="setTimeFilter('24')">24h</button>
            <button class="filter-btn" onclick="setTimeFilter('48')">48h</button>
            <button class="filter-btn" onclick="setTimeFilter('72')">72h</button>
        </div>
        
        <div class="search-container">
            <div class="search-label">üîç Rechercher un n≈ìud</div>
            <div class="search-input-container">
                <input type="text" 
                       id="searchInput" 
                       class="search-input" 
                       placeholder="Nom ou ID du n≈ìud"
                       onkeypress="handleSearchKeyPress(event)">
            </div>
            <div id="searchResultsList" class="search-results-list"></div>
            <div class="search-buttons">
                <button class="search-btn" onclick="searchNode()">Chercher</button>
                <button class="clear-btn" onclick="clearSearch()">Effacer</button>
            </div>
            <div id="searchResult" class="search-result"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
    <script>
        let map;
        let markers = {};
        let labelMarkers = {};
        let meshData = null;
        let currentFilter = '24';
        let currentView = 'both';  // Changed from 'nodes' to 'both' to show nodes + links by default
        let myNodeId = '!a2e175ac';
        let linkLayerGroup = L.layerGroup();
        let linkCount = 0;
        
        // Search result display constants
        const ID_PREFIX_LENGTH = 1;  // Length of '!' prefix in node IDs
        const MAX_ID_DISPLAY_LENGTH = 8;  // Show first 8 hex characters of node ID
        
        // URL parameter auto-search configuration
        const AUTO_SEARCH_DELAY = 500;  // Delay in ms before triggering auto-search from URL parameter
        let autoSearchNodeParam = null;  // Stores node parameter from URL for deferred search
        
        // Function to detect if a string contains emoji
        function containsEmoji(str) {
            if (!str) return false;
            // Unicode ranges for emoji detection
            // Includes standard emoji, symbols, and pictographs
            const emojiRegex = /[\u{1F600}-\u{1F64F}\u{1F300}-\u{1F5FF}\u{1F680}-\u{1F6FF}\u{1F1E0}-\u{1F1FF}\u{2600}-\u{26FF}\u{2700}-\u{27BF}\u{1F900}-\u{1F9FF}\u{1FA00}-\u{1FA6F}\u{1FA70}-\u{1FAFF}\u{FE00}-\u{FE0F}\u{1F004}\u{1F0CF}\u{1F170}-\u{1F251}]/u;
            return emojiRegex.test(str);
        }
        
        function isValidPosition(lat, lon) {
            return lat !== undefined && lon !== undefined && 
                   lat !== null && lon !== null &&
                   lat !== 0 && lon !== 0 &&
                   !isNaN(lat) && !isNaN(lon) &&
                   lat >= -90 && lat <= 90 &&
                   lon >= -180 && lon <= 180;
        }
        
        function getNodeColorByHop(hopsAway) {
            if (hopsAway === undefined || hopsAway === null) {
                return '#95a5a6'; // Gris (4+ sauts)
            }

            switch(hopsAway) {
                case 0: return '#27ae60'; // Vert (direct)
                case 1: return '#3498db'; // Bleu (1 saut)
                case 2: return '#f39c12'; // Jaune (2 sauts)
                case 3: return '#e67e22'; // Orange (3 sauts)
                case 4: return '#9b59b6'; // Violet (4 sauts)
                default: return '#95a5a6'; // Gris (5+ sauts)
            }
        }
        
        function getLinkColor(snr, source) {
            // If source is MQTT, use a distinct color (cyan/blue tint)
            if (source === 'mqtt') {
                if (snr === null || snr === undefined) return '#00bfff'; // Deep sky blue for unknown SNR
                if (snr > 5) return '#00ffff'; // Cyan - Excellent MQTT
                if (snr > 0) return '#1e90ff';  // Dodger blue - Good MQTT
                return '#4169e1';                // Royal blue - Weak MQTT
            }
            
            // "Heard via" links - brown color
            if (source === 'via') {
                return '#8B4513'; // Saddle brown - indicates relay/indirect link
            }
            
            // Radio links (default colors)
            if (snr === null || snr === undefined) return '#888888';
            if (snr > 5) return '#00ff00'; // Green - Excellent
            if (snr > 0) return '#ffff00';  // Yellow - Good
            return '#ff6600';                // Orange - Weak
        }

        function getLinkOpacity(snr, source) {
            // MQTT links slightly more transparent to distinguish them
            const baseOpacity = source === 'mqtt' ? 0.7 : 1.0;
            
            // "Heard via" links are semi-transparent to show they're indirect
            if (source === 'via') {
                return 0.5;
            }
            
            if (snr === null || snr === undefined) return 0.3 * baseOpacity;
            if (snr > 5) return 0.9 * baseOpacity;
            if (snr > 0) return 0.6 * baseOpacity;
            return 0.4 * baseOpacity;
        }

        function getLinkWeight(snr, source) {
            // MQTT links slightly thinner
            const baseWeight = source === 'mqtt' ? 0.8 : 1.0;
            
            // "Heard via" links are thinner to show they're indirect
            if (source === 'via') {
                return 2;
            }
            
            if (snr === null || snr === undefined) return 3 * baseWeight;
            if (snr > 5) return 4 * baseWeight;  // Reduced from 7 to 4 for green links
            if (snr > 0) return 5 * baseWeight;
            return 4 * baseWeight;
        }
        
        function getLinkDescription(source, isInferred) {
            if (isInferred) {
                return 'Liaison inf√©r√©e (topologie)';
            }
            if (source === 'mqtt') {
                return 'Liaison MQTT (collecteur distant)';
            }
            if (source === 'via') {
                return 'Entendu via (relay)';
            }
            return 'Liaison radio (mesure directe)';
        }
        
        function updateLinkSourceLegend(linkTypes) {
            // Get legend elements
            const legendRadio = document.getElementById('legendRadio');
            const legendMqtt = document.getElementById('legendMqtt');
            const legendInferred = document.getElementById('legendInferred');
            const legendVia = document.getElementById('legendVia');
            const linkSourcesSection = document.getElementById('linkSourcesSection');
            
            // Safety check
            if (!legendRadio || !legendMqtt || !legendInferred || !legendVia || !linkSourcesSection) {
                return;
            }
            
            // Show/hide legend items based on what's actually present
            legendRadio.style.display = linkTypes.radio ? 'flex' : 'none';
            legendMqtt.style.display = linkTypes.mqtt ? 'flex' : 'none';
            legendInferred.style.display = linkTypes.inferred ? 'flex' : 'none';
            legendVia.style.display = linkTypes.via ? 'flex' : 'none';
            
            // Hide the entire "Source des liens" section if no links exist
            const hasAnyLinks = linkTypes.radio || linkTypes.mqtt || linkTypes.inferred || linkTypes.via;
            linkSourcesSection.style.display = hasAnyLinks ? 'block' : 'none';
        }
        
        function setView(view) {
            currentView = view;
            document.querySelectorAll('.view-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Show/hide links row in stats
            const linksRow = document.getElementById('linksRow');
            if (view === 'links' || view === 'both') {
                linksRow.style.display = 'flex';
            } else {
                linksRow.style.display = 'none';
            }
            
            updateMapView();
        }
        
        function setTimeFilter(hours) {
            currentFilter = hours;
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            applyTimeFilter();
        }
        
        async function parseNodeInfo() {
            try {
                const response = await fetch('https://tigro.fr/info.json');
                const data = await response.json();
                
                console.log('‚úì JSON charg√© avec succ√®s!');
                console.log('Nombre de n≈ìuds:', Object.keys(data['Nodes in mesh']).length);
                
                return { nodes: data['Nodes in mesh'] };
            } catch (error) {
                console.error('ERREUR chargement JSON:', error);
                throw error;
            }
        }
        
        async function initMap() {
            try {
                map = L.map('map').setView([48.8566, 2.3522], 11);
                
                // OpenStreetMap layer
                const osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '¬© OpenStreetMap contributors',
                    maxZoom: 19
                });
                
                // IGN G√©oportail Orthophoto layer (using standard TileLayer with WMTS URL)
                const orthoGeoportail = L.tileLayer(
                    'https://data.geopf.fr/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=ORTHOIMAGERY.ORTHOPHOTOS&STYLE=normal&TILEMATRIXSET=PM&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}&FORMAT=image/jpeg',
                    {
                        attribution: '¬© IGN - G√©oportail',
                        maxZoom: 19
                    }
                );
                
                // OpenTopoMap - Topographic map with clear elevation/contour lines
                const openTopoMap = L.tileLayer(
                    'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png',
                    {
                        attribution: '¬© OpenTopoMap (CC-BY-SA)',
                        maxZoom: 17
                    }
                );
                
                // G√©oportail Lidar HD SURSOL (surface) layer
                const lidarSursol = L.tileLayer(
                    'https://data.geopf.fr/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=PLANIGN.LIDAR.SURSOL&STYLE=normal&TILEMATRIXSET=PM&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}&FORMAT=image/png',
                    {
                        attribution: '¬© IGN - G√©oportail Lidar HD',
                        maxZoom: 19
                    }
                );
                
                // G√©oportail Lidar HD TERRAIN layer
                const lidarTerrain = L.tileLayer(
                    'https://data.geopf.fr/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=PLANIGN.LIDAR.TERRAIN&STYLE=normal&TILEMATRIXSET=PM&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}&FORMAT=image/png',
                    {
                        attribution: '¬© IGN - G√©oportail Lidar HD',
                        maxZoom: 19
                    }
                );
                
                // Add default layer (OpenStreetMap)
                osmLayer.addTo(map);
                
                // Add layer control
                const baseLayers = {
                    "OpenStreetMap": osmLayer,
                    "Orthophoto France": orthoGeoportail,
                    "Topographie (Relief)": openTopoMap,
                    "Lidar HD - Surface": lidarSursol,
                    "Lidar HD - Terrain": lidarTerrain
                };
                L.control.layers(baseLayers, null, {position: 'topleft'}).addTo(map);
            } catch (error) {
                console.error('Error initializing map layers:', error);
                // Fallback: ensure at least the base map is shown
                if (map && !map.hasLayer(osmLayer)) {
                    osmLayer.addTo(map);
                }
            }
            
            const legend = L.control({position: 'bottomright'});
            
            legend.onAdd = () => {
                const container = L.DomUtil.create('div', 'legend-container');
                const div = L.DomUtil.create('div', 'legend');
                div.innerHTML = `
                    <h4 id="legendTitle">Distance (hops)</h4>
                    <div id="hopsLegend">
                        <div class="legend-item">
                            <div class="color-box owner-node"></div>
                            <span>Votre n≈ìud</span>
                        </div>
                        <div class="legend-item">
                            <div class="color-box" style="background-color:#27ae60"></div>
                            <span>Direct (0 hop)</span>
                        </div>
                        <div class="legend-item">
                            <div class="color-box" style="background-color:#3498db"></div>
                            <span>Hop 1</span>
                        </div>
                        <div class="legend-item">
                            <div class="color-box" style="background-color:#f39c12"></div>
                            <span>Hop 2</span>
                        </div>
                        <div class="legend-item">
                            <div class="color-box" style="background-color:#e67e22"></div>
                            <span>Hop 3</span>
                        </div>
                        <div class="legend-item">
                            <div class="color-box" style="background-color:#9b59b6"></div>
                            <span>Hop 4</span>
                        </div>
                        <div class="legend-item">
                            <div class="color-box" style="background-color:#95a5a6"></div>
                            <span>Hop 5+</span>
                        </div>
                        <div class="legend-item" style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(0,0,0,0.1);">
                            <div style="width: 20px; height: 20px; border-radius: 50%; border: 5px solid #FFD700; margin-right: 8px;"></div>
                            <span>üåê MQTT actif</span>
                        </div>
                    </div>
                    <div id="linksLegend" style="display:none;">
                        <div style="margin-bottom: 8px; font-weight: 600; color: #202124;">Qualit√© SNR:</div>
                        <div class="legend-item">
                            <div class="legend-line" style="background-color: #00ff00;"></div>
                            <span>Excellente (SNR > 5)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-line" style="background-color: #ffff00;"></div>
                            <span>Bonne (SNR 0-5)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-line" style="background-color: #ff6600;"></div>
                            <span>Faible (SNR < 0)</span>
                        </div>
                        
                        <div id="linkSourcesSection" style="margin-top: 12px; margin-bottom: 8px; padding-top: 8px; border-top: 1px solid rgba(0,0,0,0.1); font-weight: 600; color: #202124;">Source des liens:</div>
                        <div id="legendRadio" class="legend-item" style="display:none;">
                            <div class="legend-line" style="background-color: #00ff00;"></div>
                            <span>Radio (mesure directe)</span>
                        </div>
                        <div id="legendMqtt" class="legend-item" style="display:none;">
                            <div class="legend-line" style="background-color: #00ffff;"></div>
                            <span>MQTT (collecteur distant)</span>
                        </div>
                        <div id="legendInferred" class="legend-item" style="display:none;">
                            <div class="legend-line" style="background-color: #888888; opacity: 0.5;"></div>
                            <span style="opacity: 0.7;">Inf√©r√©e (topologie)</span>
                        </div>
                        <div id="legendVia" class="legend-item" style="display:none;">
                            <div class="legend-line" style="background-color: #8B4513;"></div>
                            <span>Entendu via (relay)</span>
                        </div>
                    </div>
                `;
                
                const toggle = L.DomUtil.create('button', 'legend-toggle');
                toggle.innerHTML = `
                    L√©gende
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M18 15l-6-6-6 6"/>
                    </svg>
                `;
                toggle.onclick = toggleLegend;
                toggle.setAttribute('aria-label', 'Toggle legend');
                
                container.appendChild(div);
                container.appendChild(toggle);
                return container;
            };
            
            legend.addTo(map);
            
            try {
                meshData = await parseNodeInfo();
                
                document.getElementById('totalNodes').textContent = Object.keys(meshData.nodes).length;
                
                // Centrer la carte sur votre n≈ìud si disponible
                if (meshData.nodes[myNodeId] && meshData.nodes[myNodeId].position) {
                    const myNode = meshData.nodes[myNodeId];
                    if (isValidPosition(myNode.position.latitude, myNode.position.longitude)) {
                        console.log('Centrage sur votre n≈ìud:', myNode.position.latitude, myNode.position.longitude);
                        map.setView([myNode.position.latitude, myNode.position.longitude], 13);
                    }
                }
                
                createMarkers(meshData.nodes);
                updateMapView();
                
                // If node parameter was provided in URL, search for it
                if (autoSearchNodeParam) {
                    setTimeout(() => {
                        searchNode();
                        autoSearchNodeParam = null;
                    }, AUTO_SEARCH_DELAY);
                }
            } catch (error) {
                console.error('Erreur chargement donn√©es:', error);
                document.getElementById('lastHeard').textContent = 'Erreur: ' + error.message;
            }
        }
        
        function updateMapView() {
            // Update legend
            const hopsLegend = document.getElementById('hopsLegend');
            const linksLegend = document.getElementById('linksLegend');
            const legendTitle = document.getElementById('legendTitle');
            
            // Safety check - return if elements don't exist yet
            if (!hopsLegend || !linksLegend || !legendTitle || !map) {
                return;
            }
            
            if (currentView === 'nodes') {
                hopsLegend.style.display = 'block';
                linksLegend.style.display = 'none';
                legendTitle.textContent = 'Distance (hops)';
                if (map.hasLayer(linkLayerGroup)) {
                    map.removeLayer(linkLayerGroup);
                }
            } else if (currentView === 'links') {
                hopsLegend.style.display = 'none';
                linksLegend.style.display = 'block';
                legendTitle.textContent = 'Qualit√© des liaisons';
                if (!map.hasLayer(linkLayerGroup)) {
                    map.addLayer(linkLayerGroup);
                }
                if (meshData && meshData.nodes) {
                    drawLinks(meshData.nodes);
                }
            } else if (currentView === 'both') {
                hopsLegend.style.display = 'block';
                linksLegend.style.display = 'block';
                legendTitle.textContent = 'Distance et Liaisons';
                if (!map.hasLayer(linkLayerGroup)) {
                    map.addLayer(linkLayerGroup);
                }
                if (meshData && meshData.nodes) {
                    drawLinks(meshData.nodes);
                }
            }
        }
        
        function drawLinks(nodes) {
            linkLayerGroup.clearLayers();
            linkCount = 0;
            const drawnLinks = new Set();

            // Track which link types are present
            const linkTypes = {
                radio: false,
                mqtt: false,
                inferred: false,
                via: false
            };

            // Convertir en tableau si n√©cessaire
            const nodesArray = Array.isArray(nodes) ? nodes : Object.values(nodes);
            
            let hasNeighborInfo = false;
            
            // Track which nodes have neighbor data (radio or MQTT)
            const nodesWithNeighbors = new Set();
            
            nodesArray.forEach(node => {
                const nodeId = node.user?.id || node.nodeId;
                if (!node.position || !markers[nodeId]) return;

                const neighbors = node.neighbors || node.neighbours || [];
                
                if (neighbors.length > 0) {
                    hasNeighborInfo = true;
                    
                    // Mark this node as having neighbor data
                    nodesWithNeighbors.add(nodeId);
                    
                    neighbors.forEach(neighbor => {
                        const neighborId = neighbor.nodeId || neighbor.node_id || neighbor.id;
                        if (!markers[neighborId]) return;
                        
                        const linkKey = [nodeId, neighborId].sort().join('-');
                        if (drawnLinks.has(linkKey)) return;
                        drawnLinks.add(linkKey);

                        const fromLatLng = markers[nodeId].getLatLng();
                        const toLatLng = markers[neighborId].getLatLng();
                        const snr = neighbor.snr || neighbor.SNR || null;
                        const source = neighbor.source || 'radio';  // Default to radio if not specified
                        
                        // Track link type
                        if (source === 'mqtt') {
                            linkTypes.mqtt = true;
                        } else {
                            linkTypes.radio = true;
                        }
                        
                        const line = L.polyline([fromLatLng, toLatLng], {
                            color: getLinkColor(snr, source),
                            weight: getLinkWeight(snr, source),
                            opacity: getLinkOpacity(snr, source),
                            dashArray: snr === null ? '5, 5' : null
                        });

                        let popupContent = `<strong>${getLinkDescription(source, false)}</strong><br>`;
                        popupContent += `${node.user.shortName || nodeId} ‚Üî ${markers[neighborId].options.title}<br>`;
                        if (snr !== null) popupContent += `SNR: ${snr.toFixed(1)} dB<br>`;
                        popupContent += `Source: ${source === 'mqtt' ? 'MQTT' : 'Radio'}`;
                        
                        line.bindPopup(popupContent);
                        linkLayerGroup.addLayer(line);
                        linkCount++;
                    });
                }
            });

            // Create "heard via" links ONLY for nodes with hops > 0 that DON'T have neighbor data
            // These show which relay node was likely used to hear indirect nodes
            // Skip nodes that already have formal neighbor information (radio or MQTT)
            // IMPORTANT: Skip links directly to owner node (targetHops = 0) as they have no value
            console.log('Creating "heard via" relay links for nodes without neighbor data...');
            
            nodesArray.forEach(node => {
                const nodeId = node.user?.id || node.nodeId;
                if (!node.position || !markers[nodeId]) return;
                
                // Skip nodes that already have neighbor data
                if (nodesWithNeighbors.has(nodeId)) {
                    return;
                }
                
                // Only for nodes heard via relay (hops > 0)
                if (node.hopsAway && node.hopsAway > 0) {
                    const targetHops = node.hopsAway - 1;
                    
                    // Skip if target relay would be the owner node (hops = 0)
                    // "Heard via" links to the owner node have no value since the owner is the source
                    if (targetHops === 0) {
                        return;
                    }
                    
                    // Find potential relay nodes (nodes at hopsAway - 1)
                    const potentialRelays = nodesArray.filter(n => {
                        const nId = n.user?.id || n.nodeId;
                        return nId !== nodeId && 
                               n.position && 
                               markers[nId] && 
                               (n.hopsAway === targetHops || (!n.hopsAway && targetHops === 0));
                    });
                    
                    if (potentialRelays.length > 0) {
                        // Sort by SNR to get the most likely relay
                        potentialRelays.sort((a, b) => {
                            const snrA = a.snr || -100;
                            const snrB = b.snr || -100;
                            return snrB - snrA;
                        });
                        
                        // Use the best SNR node as the likely relay
                        const relay = potentialRelays[0];
                        const relayId = relay.user?.id || relay.nodeId;
                        
                        // Only draw if we haven't already drawn this link (as neighbor or via)
                        const linkKey = [nodeId, relayId].sort().join('-');
                        if (!drawnLinks.has(linkKey)) {
                            drawnLinks.add(linkKey);
                            
                            // Track via link type
                            linkTypes.via = true;
                            
                            const fromLatLng = markers[nodeId].getLatLng();
                            const toLatLng = markers[relayId].getLatLng();
                            
                            const line = L.polyline([fromLatLng, toLatLng], {
                                color: getLinkColor(node.snr, 'via'),
                                weight: getLinkWeight(node.snr, 'via'),
                                opacity: getLinkOpacity(node.snr, 'via'),
                                dashArray: '3, 3'  // Dashed to show it's inferred
                            });

                            let popupContent = `<strong>${getLinkDescription('via', false)}</strong><br>`;
                            popupContent += `${node.user.shortName || nodeId} ‚Üí ${relay.user.shortName || relayId}<br>`;
                            popupContent += `Distance: ${node.hopsAway} hop(s)<br>`;
                            if (node.snr) popupContent += `SNR: ${node.snr.toFixed(1)} dB<br>`;
                            popupContent += `Source: Entendu via (relay probable)`;
                            
                            line.bindPopup(popupContent);
                            linkLayerGroup.addLayer(line);
                            linkCount++;
                        }
                    }
                }
            });

            // Si pas d'infos de voisinage, cr√©er des liaisons inf√©r√©es
            if (!hasNeighborInfo) {
                console.log('Pas d\'infos de voisinage - utilisation de liaisons inf√©r√©es');
                
                nodesArray.forEach(node => {
                    const nodeId = node.user?.id || node.nodeId;
                    if (!node.position || !markers[nodeId]) return;
                    
                    if (node.hopsAway && node.hopsAway > 0) {
                        const targetHops = node.hopsAway - 1;
                        const potentialParents = nodesArray.filter(n => {
                            const nId = n.user?.id || n.nodeId;
                            return nId !== nodeId && 
                                   n.position && 
                                   markers[nId] && 
                                   (n.hopsAway === targetHops || (!n.hopsAway && targetHops === 0));
                        });
                        
                        if (potentialParents.length > 0) {
                            potentialParents.sort((a, b) => {
                                const snrA = a.snr || -100;
                                const snrB = b.snr || -100;
                                return snrB - snrA;
                            });
                            
                            const parent = potentialParents[0];
                            const parentId = parent.user?.id || parent.nodeId;
                            
                            const linkKey = [nodeId, parentId].sort().join('-');
                            if (!drawnLinks.has(linkKey)) {
                                drawnLinks.add(linkKey);
                                
                                // Track inferred link type
                                linkTypes.inferred = true;
                                
                                const fromLatLng = markers[nodeId].getLatLng();
                                const toLatLng = markers[parentId].getLatLng();
                                
                                const line = L.polyline([fromLatLng, toLatLng], {
                                    color: getLinkColor(node.snr, 'radio'),  // Inferred links are always from radio topology
                                    weight: getLinkWeight(node.snr, 'radio'),
                                    opacity: getLinkOpacity(node.snr, 'radio') * 0.6,
                                    dashArray: '5, 5'
                                });

                                let popupContent = `<strong>${getLinkDescription('radio', true)}</strong><br>`;
                                popupContent += `${node.user.shortName || nodeId} ‚Üí ${parent.user.shortName || parentId}<br>`;
                                popupContent += `Distance: ${node.hopsAway} hop(s)<br>`;
                                if (node.snr) popupContent += `SNR: ${node.snr.toFixed(1)} dB<br>`;
                                popupContent += `Source: Inf√©r√© (topologie)`;
                                
                                line.bindPopup(popupContent);
                                linkLayerGroup.addLayer(line);
                                linkCount++;
                            }
                        }
                    }
                });
            }

            document.getElementById('totalLinks').textContent = linkCount;
            
            // Update legend to show only active link types
            updateLinkSourceLegend(linkTypes);
        }
        
        function createMarkers(nodes) {
            console.log('=== DEBUT createMarkers ===');
            console.log('Nombre de n≈ìuds √† traiter:', Object.keys(nodes).length);
            
            Object.values(markers).forEach(marker => {
                map.removeLayer(marker);
                // Also remove hiviz circle if it exists
                if (marker.hivizCircle) {
                    map.removeLayer(marker.hivizCircle);
                }
            });
            Object.values(labelMarkers).forEach(markerOrArray => {
                if (Array.isArray(markerOrArray)) {
                    markerOrArray.forEach(m => map.removeLayer(m));
                } else {
                    map.removeLayer(markerOrArray);
                }
            });
            markers = {};
            labelMarkers = {};
            
            let visibleCount = 0;
            let lastHeardTime = 0;
            let lastHeardNode = null;
            
            const now = Date.now() / 1000;
            
            // Track position collisions to apply offsets
            // Key: "lat,lon" -> Array of node IDs at that position
            const positionMap = new Map();
            
            // First pass: collect all valid nodes and group by position
            const validNodes = [];
            Object.entries(nodes).forEach(([id, node]) => {
                if (!isValidPosition(node.position?.latitude, node.position?.longitude)) {
                    return;
                }
                
                const lastHeard = node.lastHeard || 0;
                const hoursAgo = (now - lastHeard) / 3600;
                
                if (currentFilter !== 'all') {
                    const hours = parseInt(currentFilter);
                    if (hoursAgo > hours) {
                        return;
                    }
                }
                
                if (lastHeard > lastHeardTime) {
                    lastHeardTime = lastHeard;
                    lastHeardNode = node;
                }
                
                // Track this node for rendering
                validNodes.push([id, node]);
                
                // Group nodes by position
                const posKey = `${node.position.latitude},${node.position.longitude}`;
                if (!positionMap.has(posKey)) {
                    positionMap.set(posKey, []);
                }
                positionMap.get(posKey).push(id);
            });
            
            // Second pass: render markers with offsets for collisions
            validNodes.forEach(([id, node]) => {
                try {
                    const lat = node.position.latitude;
                    const lon = node.position.longitude;
                    
                    // Check if this position has multiple nodes
                    const posKey = `${lat},${lon}`;
                    const nodesAtPosition = positionMap.get(posKey);
                    let offsetLat = 0;
                    let offsetLon = 0;
                    
                    if (nodesAtPosition.length > 1) {
                        // Multiple nodes at same position - apply spiral offset
                        const index = nodesAtPosition.indexOf(id);
                        // Small offset in degrees (approximately 5-10 meters at mid-latitudes)
                        // Using spiral pattern: radius increases, angle increments
                        const angle = index * (2 * Math.PI / 5); // 5 positions per circle
                        const radius = 0.00005 * (1 + Math.floor(index / 5)); // ~5m base radius
                        offsetLat = radius * Math.cos(angle);
                        offsetLon = radius * Math.sin(angle);
                        console.log(`Node ${id} at collision position ${posKey}: offset by ${offsetLat.toFixed(6)}, ${offsetLon.toFixed(6)}`);
                    }
                    
                    // Apply offset to coordinates for display
                    const displayLat = lat + offsetLat;
                    const displayLon = lon + offsetLon;
                    
                    // Calculate time since last heard for popup
                    const lastHeard = node.lastHeard || 0;
                    const hoursAgo = (now - lastHeard) / 3600;
                    
                    let color;
                    if (id === myNodeId) {
                        color = '#e74c3c';
                    } else {
                        color = getNodeColorByHop(node.hopsAway);
                    }
                    
                    const marker = L.circleMarker([displayLat, displayLon], {
                        radius: id === myNodeId ? 28 : 20,
                        fillColor: color,
                        color: '#fff',
                        weight: 2,
                        opacity: 1,
                        fillOpacity: 0.8,
                        title: node.user?.shortName || id
                    });
                    
                    // Add tooltip with longName that shows on hover
                    const longName = node.user?.longName || 'N≈ìud inconnu';
                    marker.bindTooltip(longName, {
                        permanent: false,
                        direction: 'top',
                        className: 'node-tooltip'
                    });
                    
                    // Create emoji marker centered in the circle (using shortName)
                    const shortName = node.user?.shortName || '';
                    if (shortName) {
                        const hasEmoji = containsEmoji(shortName);
                        const emojiClass = hasEmoji ? 'node-emoji emoji-only' : 'node-emoji text-only';
                        const emojiIcon = L.divIcon({
                            html: `<div class="${emojiClass}">${shortName}</div>`,
                            className: '',
                            iconSize: [null, null]
                        });
                        
                        const emojiMarker = L.marker([displayLat, displayLon], {
                            icon: emojiIcon,
                            interactive: false
                        });
                        emojiMarker.addTo(map);
                        // Store emoji marker reference for cleanup
                        if (!labelMarkers[id]) {
                            labelMarkers[id] = [];
                        }
                        if (Array.isArray(labelMarkers[id])) {
                            labelMarkers[id].push(emojiMarker);
                        } else {
                            labelMarkers[id] = [labelMarkers[id], emojiMarker];
                        }
                        
                        // Only create label (longName) if shortName doesn't contain an emoji
                        if (!hasEmoji) {
                            // Create a divIcon with text label using longName on the side
                            const labelText = node.user?.longName || (id.startsWith('!') ? id.substring(id.length - 4) : id.substring(0, 4));
                            const labelIcon = L.divIcon({
                                html: `<div class="node-label">${labelText}</div>`,
                                className: '',
                                iconSize: [null, null]
                            });
                            
                            const labelMarker = L.marker([displayLat, displayLon], {
                                icon: labelIcon,
                                interactive: false
                            });
                            labelMarker.addTo(map);
                            // Handle array of markers
                            if (Array.isArray(labelMarkers[id])) {
                                labelMarkers[id].push(labelMarker);
                            } else {
                                labelMarkers[id] = [labelMarkers[id], labelMarker];
                            }
                        }
                    } else {
                        // No shortName - create label with longName
                        const labelText = node.user?.longName || (id.startsWith('!') ? id.substring(id.length - 4) : id.substring(0, 4));
                        const labelIcon = L.divIcon({
                            html: `<div class="node-label">${labelText}</div>`,
                            className: '',
                            iconSize: [null, null]
                        });
                        
                        const labelMarker = L.marker([displayLat, displayLon], {
                            icon: labelIcon,
                            interactive: false
                        });
                        labelMarker.addTo(map);
                        // Handle array of markers
                        if (!labelMarkers[id]) {
                            labelMarkers[id] = labelMarker;
                        } else if (Array.isArray(labelMarkers[id])) {
                            labelMarkers[id].push(labelMarker);
                        } else {
                            labelMarkers[id] = [labelMarkers[id], labelMarker];
                        }
                    }
                    
                    marker.on('mouseover', function() {
                        this.setStyle({ fillOpacity: 1 });
                    });
                    
                    marker.on('mouseout', function() {
                        this.setStyle({ fillOpacity: 0.8 });
                    });
                    
                    const lastHeardDate = new Date(lastHeard * 1000);
                    const hoursAgoText = hoursAgo < 1 ? 
                        `Il y a ${Math.floor(hoursAgo * 60)} minutes` : 
                        `Il y a ${Math.floor(hoursAgo)} heures`;
                    
                    let popupContent = `<div class="popup-title">${node.user?.longName || 'N≈ìud inconnu'}</div>`;
                    popupContent += `<div class="popup-info">`;
                    popupContent += `<strong>ID:</strong> ${node.user?.shortName || id}<br>`;
                    
                    // Add hwModel if available
                    if (node.user?.hwModel) {
                        popupContent += `<strong>Mod√®le:</strong> ${node.user.hwModel}<br>`;
                    }
                    
                    popupContent += `<strong>Hops:</strong> ${node.hopsAway !== undefined ? node.hopsAway : 'N/A'}<br>`;
                    popupContent += `<strong>SNR:</strong> ${node.snr !== undefined ? node.snr.toFixed(1) + ' dB' : 'N/A'}<br>`;
                    
                    // Add neighbor list with clickable links
                    if (node.neighbors || node.neighbours) {
                        const neighbors = node.neighbors || node.neighbours;
                        const neighborCount = neighbors.length;
                        popupContent += `<strong>Voisins directs:</strong> ${neighborCount}<br>`;
                        
                        if (neighborCount > 0) {
                            popupContent += `<div style="margin-left: 10px; margin-top: 5px;">`;
                            neighbors.forEach((neighbor, index) => {
                                const neighborId = neighbor.nodeId || neighbor.node_id || neighbor.id;
                                const neighborNode = meshData.nodes[neighborId];
                                const neighborName = neighborNode?.user?.longName || neighborId;
                                const snrText = neighbor.snr !== undefined && neighbor.snr !== null ? ` (${neighbor.snr.toFixed(1)} dB)` : '';
                                
                                // Create clickable link to map.html?node=longName
                                popupContent += `<a href="map.html?node=${encodeURIComponent(neighborName)}" style="color: #1a73e8; text-decoration: none;">${neighborName}</a>${snrText}`;
                                
                                // Add line break if not the last neighbor
                                if (index < neighborCount - 1) {
                                    popupContent += `<br>`;
                                }
                            });
                            popupContent += `</div>`;
                        }
                    }
                    
                    if (node.mqttActive) {
                        popupContent += `<strong>üåê MQTT:</strong> <span style="color: #FFD700; font-weight: bold;">Actif</span><br>`;
                    }
                    popupContent += `<strong>Dernier contact:</strong> ${lastHeardDate.toLocaleString('fr-FR')}<br>`;
                    popupContent += `<em>${hoursAgoText}</em>`;
                    popupContent += `</div>`;
                    
                    marker.bindPopup(popupContent);
                    marker.addTo(map);
                    markers[id] = marker;
                    
                    // Add yellow hi-viz circle for MQTT-active nodes
                    if (node.mqttActive) {
                        const hivizCircle = L.circleMarker([displayLat, displayLon], {
                            radius: id === myNodeId ? 36 : 28,
                            fillColor: 'transparent',
                            color: '#FFD700',  // Bright yellow/gold
                            weight: 5,
                            opacity: 1,
                            fillOpacity: 0,
                            className: 'mqtt-active-hiviz',
                            interactive: false
                        });
                        hivizCircle.addTo(map);
                        // Store reference to hiviz circle for cleanup
                        if (!markers[id].hivizCircle) {
                            markers[id].hivizCircle = hivizCircle;
                        }
                    }
                    
                    visibleCount++;
                } catch (error) {
                    console.error(`Erreur cr√©ation marqueur ${id}:`, error);
                }
            });
            
            console.log(`Total marqueurs cr√©√©s: ${visibleCount}`);
            
            document.getElementById('visibleNodes').textContent = visibleCount;
            if (lastHeardNode) {
                const lastHeardDate = new Date(lastHeardTime * 1000);
                document.getElementById('lastHeard').textContent = 
                    `${lastHeardNode.user?.longName || 'N≈ìud'} √† ${lastHeardDate.toLocaleTimeString('fr-FR')}`;
            }
        }
        
        function applyTimeFilter() {
            if (meshData) {
                createMarkers(meshData.nodes);
                updateMapView();
            }
        }
        
        let highlightedMarker = null;
        
        function handleSearchKeyPress(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                searchNode();
            }
        }
        
        function searchNode() {
            const searchTerm = document.getElementById('searchInput').value.trim();
            const resultDiv = document.getElementById('searchResult');
            const resultsListDiv = document.getElementById('searchResultsList');
            
            // Clear previous results
            resultsListDiv.innerHTML = '';
            resultsListDiv.classList.remove('visible');
            
            if (!searchTerm) {
                resultDiv.textContent = 'Veuillez entrer un nom de n≈ìud';
                resultDiv.className = 'search-result error';
                return;
            }
            
            if (!meshData || !meshData.nodes) {
                resultDiv.textContent = 'Donn√©es non charg√©es';
                resultDiv.className = 'search-result error';
                return;
            }
            
            // Clear previous highlight
            if (highlightedMarker) {
                highlightedMarker.getElement()?.classList.remove('highlighted-marker');
            }
            
            // Search for all matching nodes (case-insensitive)
            const searchLower = searchTerm.toLowerCase();
            let foundNodes = [];
            
            for (const [id, node] of Object.entries(meshData.nodes)) {
                const shortName = node.user?.shortName?.toLowerCase() || '';
                const longName = node.user?.longName?.toLowerCase() || '';
                const nodeId = id.toLowerCase();
                
                // For node ID matching, strip the '!' prefix to enable short hex ID searches
                // This allows searches like "f5k1" or "40ad" to match "!12f5k123" or "!ab40ad45"
                const nodeIdHex = nodeId.startsWith('!') ? nodeId.substring(1) : nodeId;
                
                if (shortName.includes(searchLower) || 
                    longName.includes(searchLower) || 
                    nodeId.includes(searchLower) ||
                    nodeIdHex.includes(searchLower)) {
                    foundNodes.push({ id, node });
                }
            }
            
            if (foundNodes.length === 0) {
                resultDiv.textContent = `Aucun n≈ìud trouv√© pour "${searchTerm}"`;
                resultDiv.className = 'search-result error';
                return;
            }
            
            // If only one result, zoom directly
            if (foundNodes.length === 1) {
                zoomToNode(foundNodes[0].id, foundNodes[0].node, resultDiv);
                return;
            }
            
            // Multiple results - show listbox
            resultDiv.textContent = `${foundNodes.length} n≈ìuds trouv√©s`;
            resultDiv.className = 'search-result success';
            
            foundNodes.forEach(({ id, node }) => {
                const item = document.createElement('div');
                item.className = 'search-result-item';
                
                const displayName = node.user?.longName || node.user?.shortName || id;
                const nodeIdShort = id.startsWith('!') ? 
                    id.substring(ID_PREFIX_LENGTH, ID_PREFIX_LENGTH + MAX_ID_DISPLAY_LENGTH) : 
                    id.substring(0, MAX_ID_DISPLAY_LENGTH);
                
                // Check if node is visible (filtered by time)
                const isVisible = markers[id] !== undefined;
                
                // Create node name element
                const nameDiv = document.createElement('div');
                nameDiv.className = 'node-name';
                nameDiv.textContent = displayName;
                
                if (!isVisible) {
                    const filteredSpan = document.createElement('span');
                    filteredSpan.className = 'filtered-tag';
                    filteredSpan.textContent = ' (filtr√© - sera affich√©)';
                    nameDiv.appendChild(filteredSpan);
                }
                
                // Create node ID element
                const idDiv = document.createElement('div');
                idDiv.className = 'node-id';
                idDiv.textContent = `ID: ${nodeIdShort}`;
                
                item.appendChild(nameDiv);
                item.appendChild(idDiv);
                
                // Allow clicking on all nodes, even if filtered
                item.onclick = () => {
                    zoomToNode(id, node, resultDiv);
                    resultsListDiv.classList.remove('visible');
                };
                
                resultsListDiv.appendChild(item);
            });
            
            resultsListDiv.classList.add('visible');
        }
        
        function createSingleMarker(id, node, isSearchResult = false) {
            // Don't recreate if marker already exists
            if (markers[id] && !isSearchResult) {
                return markers[id];
            }
            
            // Remove existing marker if recreating
            if (markers[id]) {
                map.removeLayer(markers[id]);
                if (markers[id].hivizCircle) {
                    map.removeLayer(markers[id].hivizCircle);
                }
            }
            if (labelMarkers[id]) {
                if (Array.isArray(labelMarkers[id])) {
                    labelMarkers[id].forEach(m => map.removeLayer(m));
                } else {
                    map.removeLayer(labelMarkers[id]);
                }
            }
            
            const lat = node.position.latitude;
            const lon = node.position.longitude;
            
            const now = Date.now() / 1000;
            const lastHeard = node.lastHeard || 0;
            const hoursAgo = (now - lastHeard) / 3600;
            
            let color;
            if (id === myNodeId) {
                color = '#e74c3c';
            } else {
                color = getNodeColorByHop(node.hopsAway);
            }
            
            // For search results, add a distinctive border
            const markerOptions = {
                radius: id === myNodeId ? 28 : 20,
                fillColor: color,
                color: isSearchResult ? '#FF00FF' : '#fff',  // Magenta border for searched nodes
                weight: isSearchResult ? 4 : 2,
                opacity: 1,
                fillOpacity: 0.8,
                title: node.user?.shortName || id
            };
            
            const marker = L.circleMarker([lat, lon], markerOptions);
            
            // Add tooltip with longName that shows on hover
            const longName = node.user?.longName || 'N≈ìud inconnu';
            marker.bindTooltip(longName, {
                permanent: false,
                direction: 'top',
                className: 'node-tooltip'
            });
            
            // Create emoji marker centered in the circle (using shortName)
            const shortName = node.user?.shortName || '';
            const markers_to_store = [];
            if (shortName) {
                const hasEmoji = containsEmoji(shortName);
                const emojiClass = hasEmoji ? 'node-emoji emoji-only' : 'node-emoji text-only';
                const emojiIcon = L.divIcon({
                    html: `<div class="${emojiClass}">${shortName}</div>`,
                    className: '',
                    iconSize: [null, null]
                });
                
                const emojiMarker = L.marker([lat, lon], {
                    icon: emojiIcon,
                    interactive: false
                });
                emojiMarker.addTo(map);
                markers_to_store.push(emojiMarker);
                
                // Only create label (longName) if shortName doesn't contain an emoji
                if (!hasEmoji) {
                    const labelText = node.user?.longName || (id.startsWith('!') ? id.substring(id.length - 4) : id.substring(0, 4));
                    const labelIcon = L.divIcon({
                        html: `<div class="node-label">${labelText}</div>`,
                        className: '',
                        iconSize: [null, null]
                    });
                    
                    const labelMarker = L.marker([lat, lon], {
                        icon: labelIcon,
                        interactive: false
                    });
                    labelMarker.addTo(map);
                    markers_to_store.push(labelMarker);
                }
            } else {
                // No shortName - create label with longName
                const labelText = node.user?.longName || (id.startsWith('!') ? id.substring(id.length - 4) : id.substring(0, 4));
                const labelIcon = L.divIcon({
                    html: `<div class="node-label">${labelText}</div>`,
                    className: '',
                    iconSize: [null, null]
                });
                
                const labelMarker = L.marker([lat, lon], {
                    icon: labelIcon,
                    interactive: false
                });
                labelMarker.addTo(map);
                markers_to_store.push(labelMarker);
            }
            
            // Store markers (emoji + label)
            labelMarkers[id] = markers_to_store;
            
            marker.on('mouseover', function() {
                this.setStyle({ fillOpacity: 1 });
            });
            
            marker.on('mouseout', function() {
                this.setStyle({ fillOpacity: 0.8 });
            });
            
            const lastHeardDate = new Date(lastHeard * 1000);
            const hoursAgoText = hoursAgo < 1 ? 
                `Il y a ${Math.floor(hoursAgo * 60)} minutes` : 
                `Il y a ${Math.floor(hoursAgo)} heures`;
            
            let popupContent = `<div class="popup-title">${node.user?.longName || 'N≈ìud inconnu'}</div>`;
            popupContent += `<div class="popup-info">`;
            popupContent += `<strong>ID:</strong> ${node.user?.shortName || id}<br>`;
            popupContent += `<strong>Hops:</strong> ${node.hopsAway !== undefined ? node.hopsAway : 'N/A'}<br>`;
            popupContent += `<strong>SNR:</strong> ${node.snr !== undefined ? node.snr.toFixed(1) + ' dB' : 'N/A'}<br>`;
            if (node.neighbors || node.neighbours) {
                const neighborCount = (node.neighbors || node.neighbours).length;
                popupContent += `<strong>Voisins directs:</strong> ${neighborCount}<br>`;
            }
            if (node.mqttActive) {
                popupContent += `<strong>üåê MQTT:</strong> <span style="color: #FFD700; font-weight: bold;">Actif</span><br>`;
            }
            popupContent += `<strong>Dernier contact:</strong> ${lastHeardDate.toLocaleString('fr-FR')}<br>`;
            popupContent += `<em>${hoursAgoText}</em>`;
            if (isSearchResult) {
                popupContent += `<br><strong style="color: #FF00FF;">‚ö† Affich√© via recherche (hors filtre temps)</strong>`;
            }
            popupContent += `</div>`;
            
            marker.bindPopup(popupContent);
            marker.addTo(map);
            markers[id] = marker;
            
            // Add yellow hi-viz circle for MQTT-active nodes
            if (node.mqttActive) {
                const hivizCircle = L.circleMarker([lat, lon], {
                    radius: id === myNodeId ? 36 : 28,
                    fillColor: 'transparent',
                    color: '#FFD700',  // Bright yellow/gold
                    weight: 5,
                    opacity: 1,
                    fillOpacity: 0,
                    className: 'mqtt-active-hiviz',
                    interactive: false
                });
                hivizCircle.addTo(map);
                markers[id].hivizCircle = hivizCircle;
            }
            
            return marker;
        }
        
        function zoomToNode(nodeId, node, resultDiv) {
            // If marker doesn't exist (filtered by time), create it temporarily for search
            if (!markers[nodeId]) {
                // Check if node has valid position
                if (!isValidPosition(node.position?.latitude, node.position?.longitude)) {
                    resultDiv.textContent = `N≈ìud "${node.user?.longName || nodeId}" trouv√© mais sans position GPS valide`;
                    resultDiv.className = 'search-result error';
                    return;
                }
                
                // Create temporary marker for this searched node
                createSingleMarker(nodeId, node, true);
                
                // Update visible count
                const currentVisible = parseInt(document.getElementById('visibleNodes').textContent) || 0;
                document.getElementById('visibleNodes').textContent = currentVisible + 1;
            }
            
            // Success - zoom to node and highlight
            const marker = markers[nodeId];
            const position = marker.getLatLng();
            
            // Zoom to node
            map.setView(position, 15, {
                animate: true,
                duration: 1
            });
            
            // Highlight marker with animation
            setTimeout(() => {
                marker.getElement()?.classList.add('highlighted-marker');
                highlightedMarker = marker;
                
                // Open popup
                marker.openPopup();
            }, 500);
            
            // Show success message
            const displayName = node.user?.longName || node.user?.shortName || nodeId;
            resultDiv.textContent = `‚úì Trouv√©: ${displayName}`;
            resultDiv.className = 'search-result success';
            
            // Hide results list
            document.getElementById('searchResultsList').classList.remove('visible');
        }
        
        function clearSearch() {
            document.getElementById('searchInput').value = '';
            document.getElementById('searchResult').textContent = '';
            
            // Clear results list
            const resultsListDiv = document.getElementById('searchResultsList');
            resultsListDiv.innerHTML = '';
            resultsListDiv.classList.remove('visible');
            
            // Remove highlight
            if (highlightedMarker) {
                highlightedMarker.getElement()?.classList.remove('highlighted-marker');
                highlightedMarker.closePopup();
                highlightedMarker = null;
            }
            
            // Reset view to default (Paris center if no myNode)
            if (meshData && meshData.nodes && meshData.nodes[myNodeId] && meshData.nodes[myNodeId].position) {
                const myNode = meshData.nodes[myNodeId];
                if (isValidPosition(myNode.position.latitude, myNode.position.longitude)) {
                    map.setView([myNode.position.latitude, myNode.position.longitude], 13, {
                        animate: true,
                        duration: 1
                    });
                }
            } else {
                map.setView([48.8566, 2.3522], 11, {
                    animate: true,
                    duration: 1
                });
            }
        }
        
        // Check for URL parameters to set initial view
        function initFromURLParams() {
            const urlParams = new URLSearchParams(window.location.search);
            const viewParam = urlParams.get('view');
            const nodeParam = urlParams.get('node');
            
            if (viewParam && ['nodes', 'links', 'both'].includes(viewParam)) {
                currentView = viewParam;
                
                // Update button states
                document.querySelectorAll('.view-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                
                // Activate the correct button based on viewParam
                const buttons = document.querySelectorAll('.view-btn');
                if (viewParam === 'nodes' && buttons[0]) {
                    buttons[0].classList.add('active');
                } else if (viewParam === 'links' && buttons[1]) {
                    buttons[1].classList.add('active');
                } else if (viewParam === 'both' && buttons[2]) {
                    buttons[2].classList.add('active');
                }
                
                // Show/hide links row
                const linksRow = document.getElementById('linksRow');
                if (linksRow && (viewParam === 'links' || viewParam === 'both')) {
                    linksRow.style.display = 'flex';
                }
            }
            
            // Handle node parameter for automatic search and zoom
            if (nodeParam) {
                // Set the search input value
                const searchInput = document.getElementById('searchInput');
                if (searchInput) {
                    searchInput.value = nodeParam;
                }
                
                // Store parameter for deferred search after map data loads
                autoSearchNodeParam = nodeParam;
            }
        }
        
        // Toggle functions for collapsible panels
        function toggleStats() {
            const statsPanel = document.querySelector('.stats');
            const isCollapsed = statsPanel.classList.toggle('collapsed');
            
            // Save state to localStorage
            try {
                localStorage.setItem('statsCollapsed', isCollapsed ? 'true' : 'false');
            } catch (e) {
                console.warn('localStorage not available:', e);
            }
        }
        
        function toggleLegend() {
            const legendPanel = document.querySelector('.legend');
            const isCollapsed = legendPanel.classList.toggle('collapsed');
            
            // Save state to localStorage
            try {
                localStorage.setItem('legendCollapsed', isCollapsed ? 'true' : 'false');
            } catch (e) {
                console.warn('localStorage not available:', e);
            }
        }
        
        // Restore collapsed states from localStorage
        function restoreCollapsedStates() {
            try {
                // Restore stats panel state
                const statsCollapsed = localStorage.getItem('statsCollapsed');
                if (statsCollapsed === 'true') {
                    document.querySelector('.stats')?.classList.add('collapsed');
                }
                
                // Restore legend state
                const legendCollapsed = localStorage.getItem('legendCollapsed');
                if (legendCollapsed === 'true') {
                    document.querySelector('.legend')?.classList.add('collapsed');
                }
                
                // Auto-collapse on mobile screens (< 768px)
                if (window.innerWidth < 768) {
                    // Only auto-collapse if user hasn't explicitly set a preference
                    if (statsCollapsed === null) {
                        document.querySelector('.stats')?.classList.add('collapsed');
                    }
                    if (legendCollapsed === null) {
                        document.querySelector('.legend')?.classList.add('collapsed');
                    }
                }
            } catch (e) {
                console.warn('localStorage not available:', e);
            }
        }
        
        // Initialize everything when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            initFromURLParams();
            restoreCollapsedStates();
            initMap();
        });
    </script>
</body>
</html>
