#!/usr/bin/env python3
"""
Configuration centralisée pour le bot Meshtastic
"""

# Configuration Meshtastic
SERIAL_PORT = "/dev/ttyACM0"

# Configuration Llama
LLAMA_HOST = "127.0.0.1"
LLAMA_PORT = 8080

# Configuration ESPHome
ESPHOME_HOST = "192.168.1.27"
ESPHOME_PORT = 80

# Configuration nœuds distants
REMOTE_NODE_HOST = "192.168.1.38"
REMOTE_NODE_NAME = "tigrog2"
TIGROG2_NODE_ID = 0x16fad3dc

# ========================================
# CONFIGURATION ARCHITECTURE NŒUDS
# ========================================

# Traiter les commandes depuis tigrog2 (TCP) en plus du serial
# True = Accepter commandes de tigrobot (serial) ET tigrog2 (TCP) - Configuration hybride
# False = Accepter commandes UNIQUEMENT de tigrobot (serial) - Configuration historique
PROCESS_TCP_COMMANDS = False  # Activer pour tester tigrog2 comme node messageable

# Configuration base de données des nœuds
NODE_NAMES_FILE = "node_names.json"
NODE_UPDATE_INTERVAL = 300  # 5 minutes

# Configuration affichage des métriques de signal
SHOW_RSSI = False  # Afficher les valeurs RSSI (-85dB)
SHOW_SNR = False   # Afficher les valeurs SNR (SNR:8.5)
COLLECT_SIGNAL_METRICS = True  # Collecter RSSI/SNR pour le tri

# Limites mémoire
MAX_CACHE_SIZE = 5
MAX_RX_HISTORY = 50
MAX_CONTEXT_MESSAGES = 6  # 3 échanges (user + assistant)
CONTEXT_TIMEOUT = 1800  # 30 minutes

# Limites messages
MAX_MESSAGE_SIZE = 180

# Configuration throttling commandes
MAX_COMMANDS_PER_WINDOW = 5  # Nombre max de commandes
COMMAND_WINDOW_SECONDS = 300  # Fenêtre de temps en secondes (5 minutes)

# Configuration IA pour Meshtastic (LoRa) - Réponses très courtes
MESH_AI_CONFIG = {
    "system_prompt": "Tu es un assistant accessible via le réseau Meshtastic en LoRa. Réponds en français, très court, 320 caractères maximum. Sois précis et concis, maintiens la continuité de la conversation.",
    "max_tokens": 1500,
    "temperature": 0.7,
    "top_p": 0.95,
    "top_k": 20,
    "timeout": 60,  # 1 minute pour LoRa
    "max_response_chars": 320
}

# Configuration IA pour Telegram - Réponses plus développées
TELEGRAM_AI_CONFIG = {
    "system_prompt": "Tu es un assistant intelligent accessible via Telegram, connecté à un réseau Meshtastic LoRa. Tu peux donner des réponses plus détaillées et développées. Réponds en français de manière claire et complète, tu peux utiliser des emojis pour rendre tes réponses plus engageantes. Tu es utile, créatif et bienveillant.",
    "max_tokens": 4000,
    "temperature": 0.8,  # Légèrement plus créatif pour Telegram
    "top_p": 0.95,
    "top_k": 25,
    "timeout": 120,  # 2 minutes pour Telegram
    "max_response_chars": 3000  # Plus long pour Telegram
}

# ID utilisateur CLI
CLI_USER_ID = 0xC11A0001  # ID fictif pour la CLI
CLI_TO_MESH_MAPPING = {
    # Par défaut, la CLI n'a pas de mapping mesh
    # Décommenter et configurer si besoin:
    # 0xCLI00001: {
    0xC11A0001: {
        "mesh_name": "tigro"
    }
}

CLI_SERVER_HOST = '127.0.0.1'
CLI_SERVER_PORT = 9999

# Configuration AI pour CLI
CLI_AI_CONFIG = {
    "system_prompt": "Tu es un assistant intelligent accessible via CLI locale...",
    "max_tokens": 4000,
    "temperature": 0.8,
    "timeout": 120,
    "max_response_chars": 3000
}

# ========================================
# CONFIGURATION PLATEFORMES MESSAGERIE
# ========================================

# Configuration Telegram Bridge
TELEGRAM_ENABLED = True  # Activer/désactiver l'intégration Telegram
TELEGRAM_BOT_TOKEN = "******************"  # Token du bot Telegram

# NOTE: Avec la nouvelle architecture modulaire, vous pouvez :
# 1. Désactiver Telegram en mettant TELEGRAM_ENABLED = False
# 2. Ajouter Discord en activant DISCORD_ENABLED = True (futur)
# 3. Activer la CLI locale avec CLI_ENABLED = True
# 4. Utiliser plusieurs plateformes en même temps
# Voir platform_config.py pour la configuration détaillée

# Utilisateurs Telegram autorisés (liste vide = tous autorisés)
# Format: [123456789, 987654321, ...]
TELEGRAM_AUTHORIZED_USERS = []

# Mapping des utilisateurs Telegram vers des identités Meshtastic
# Format: {telegram_id: {"node_id": 0x..., "short_name": "...", "display_name": "..."}}
TELEGRAM_TO_MESH_MAPPING = {
    # Ajouter d'autres mappings ici si nécessaire
    # 987654321: {
    #     "node_id": 0x12345678,
    #     "short_name": "autre",
    #     "display_name": "Autre User"
    # }
}

# ========================================
# CONFIGURATION CLI SERVEUR
# ========================================

# Serveur CLI TCP pour clients externes (cli_client.py)
CLI_ENABLED = False  # Activer/désactiver le serveur CLI (utile pour dev/debug)
CLI_SERVER_HOST = '127.0.0.1'  # Écoute seulement en local (sécurité)
CLI_SERVER_PORT = 9999  # Port du serveur CLI

# Configuration IA pour CLI - Similaire à Telegram mais sans emojis
CLI_AI_CONFIG = {
    "system_prompt": "Tu es un assistant intelligent accessible via CLI locale. Réponds en français de manière claire et complète. Tu es utile et précis.",
    "max_tokens": 4000,
    "temperature": 0.8,
    "top_p": 0.95,
    "top_k": 25,
    "timeout": 120,
    "max_response_chars": 3000
}

# ID utilisateur CLI (utilisé pour throttling et logs)
CLI_USER_ID = 0xC11A0001  # ID fictif pour la CLI (CLI = C11)

# Mapping CLI vers identité Mesh (optionnel)
# Si défini, les messages CLI apparaîtront comme venant de ce nœud
CLI_TO_MESH_MAPPING = {
    # Par défaut, la CLI n'a pas de mapping mesh
    # Décommenter et configurer si besoin:
    # 0xC11A0001: {
    #     "mesh_id": 0x12345678,
    #     "mesh_name": "DevUser"
    # }
}

# ========================================
# CONFIGURATION ALERTES TELEGRAM
# ========================================

# Utilisateurs Telegram à alerter (IDs Telegram)
# Si vide, utilise TELEGRAM_AUTHORIZED_USERS
TELEGRAM_ALERT_USERS = [010000000]  # Ajouter les IDs des utilisateurs à alerter

# Configuration monitoring température CPU
TEMP_WARNING_ENABLED = True  # Activer/désactiver les alertes température
TEMP_WARNING_THRESHOLD = 60  # Température en °C déclenchant une alerte
TEMP_WARNING_DURATION = 300  # Durée en secondes avant alerte (5 minutes)
TEMP_CRITICAL_THRESHOLD = 68.0  # Température critique
TEMP_CHECK_INTERVAL = 60  # Vérifier la température toutes les 60 secondes

# Configuration monitoring tigrog2
TIGROG2_MONITORING_ENABLED = True  # Activer/désactiver le monitoring tigrog2
TIGROG2_CHECK_INTERVAL = 120  # Vérifier tigrog2 toutes les 2 minutes
TIGROG2_TIMEOUT = 20  # Timeout de connexion en secondes
TIGROG2_ALERT_ON_REBOOT = True  # Alerter lors d'un redémarrage détecté
TIGROG2_ALERT_ON_DISCONNECT = True  # Alerter si tigrog2 devient inaccessible

# Configuration monitoring CPU du bot
CPU_WARNING_ENABLED = True  # Activer/désactiver les alertes CPU
CPU_WARNING_THRESHOLD = 90  # % CPU déclenchant une alerte (80%)
CPU_WARNING_DURATION = 300  # Durée en secondes avant alerte (5 minutes)
CPU_CRITICAL_THRESHOLD = 150  # % CPU critique (150% = 1.5 cœurs)
CPU_CHECK_INTERVAL = 30  # Vérifier le CPU toutes les 30 secondes

# Configuration vigilance météo Météo-France
VIGILANCE_ENABLED = True  # Activer/désactiver la surveillance vigilance météo
VIGILANCE_DEPARTEMENT = '75'  # Numéro du département à surveiller (ex: '75' pour Paris, '25' pour Doubs)
VIGILANCE_CHECK_INTERVAL = 900  # Vérifier toutes les 15 minutes (900 secondes)
VIGILANCE_ALERT_THROTTLE = 3600  # Minimum 1h entre deux alertes (3600 secondes)
VIGILANCE_ALERT_LEVELS = ['Orange', 'Rouge']  # Niveaux déclenchant une alerte automatique
# Note: Niveaux disponibles: 'Vert', 'Jaune', 'Orange', 'Rouge'

# Configuration surveillance éclairs Blitzortung.org
BLITZ_ENABLED = True  # Activer/désactiver la surveillance des éclairs
BLITZ_LATITUDE = 0.0  # Latitude du point de surveillance (0.0 = auto-détection depuis GPS du node)
BLITZ_LONGITUDE = 0.0  # Longitude du point de surveillance (0.0 = auto-détection depuis GPS du node)
BLITZ_RADIUS_KM = 50  # Rayon de surveillance en km (défaut: 50km)
BLITZ_CHECK_INTERVAL = 900  # Vérifier toutes les 15 minutes (900 secondes)
BLITZ_WINDOW_MINUTES = 15  # Fenêtre temporelle pour comptage éclairs (15min)
# Note: Position GPS auto-détectée depuis le node Meshtastic local
#       Si auto-détection échoue, spécifier BLITZ_LATITUDE/BLITZ_LONGITUDE manuellement
# Utilise le serveur MQTT public: blitzortung.ha.sed.pl:1883
# Dépendances: pip install paho-mqtt pygeohash

REBOOT_AUTHORIZED_USERS = [
    11234530,    # trusted Telegram ID
    0x16fad3dc    # trusted mesh id
]
REBOOT_PASSWORD = "your_password_secret"
REBOOT_COMMANDS_ENABLED = True

# Variables globales d'état
DEBUG_MODE = True
